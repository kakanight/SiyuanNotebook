{"ID":"20250728172928-e3o3u0v","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250728172928-e3o3u0v","title":"C++泛型编程","type":"doc","updated":"20250728174634"},"Children":[{"ID":"20250728172928-xudc5m0","Type":"NodeParagraph","Properties":{"id":"20250728172928-xudc5m0","updated":"20250728173034"},"Children":[{"Type":"NodeText","Data":"C++中的泛型弥补了作为强类型语言无法做到像是动态语言python，javascript，一样编写一段通用的逻辑实现任意类型变量传递。"}]},{"ID":"20250728173036-mrnxdy3","Type":"NodeParagraph","Properties":{"id":"20250728173036-mrnxdy3","updated":"20250728173121"},"Children":[{"Type":"NodeText","Data":"把通用逻辑设计为模版，减轻了一定限制，提供了继承机制之外的另一种抽象机制。"}]},{"ID":"20250728173122-z03fspz","Type":"NodeParagraph","Properties":{"custom-riff-decks":"20230218211946-2kw8jgx","id":"20250728173122-z03fspz","updated":"20250728173239"},"Children":[{"Type":"NodeText","Data":"模版本身不参与编译，而是编译器根据模版的用户使用模版时提供的类型参数生成代码，再进行编译，这一过程也叫做模版实例化。提供不同类型的参数，实例化不同的代码。"}]},{"ID":"20250728173244-8aif2hu","Type":"NodeParagraph","Properties":{"id":"20250728173244-8aif2hu","updated":"20250728173306"},"Children":[{"Type":"NodeText","Data":"处理不同类型的公共逻辑抽象成函数，得到了函数模版。"}]},{"ID":"20250728173311-wy6hmhi","Type":"NodeParagraph","Properties":{"id":"20250728173311-wy6hmhi","updated":"20250728173741"},"Children":[{"Type":"NodeText","Data":"累加模版函数："}]},{"ID":"20250728173742-gm0kgqg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250728173742-gm0kgqg","updated":"20250728174634"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"cm9z"},{"Type":"NodeCodeBlockCode","Data":"template\u003ctypename It\u003e\nauto sum(It begin,It end) -\u003e decltype(*begin) {\nif (begin == end ) return decltype(*begin)();\ndecltype(*begin) res = *begin;\nfor(auto it = begin+1;it != end;it++){\n\tres = res+ *it;\n}\nreturn res;\n}\n\nvector\u003cint\u003e v = {1,2,3,4};\nauto s = sum(v.begin(),v.end());\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]}]}